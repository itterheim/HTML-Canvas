{"version":3,"sources":["ts/Collider.ts","ts/Controls.ts","ts/Player.ts","ts/TileMap.ts","ts/Game.ts","ts/App.ts","ts/generative.ts"],"names":[],"mappings":"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","file":"generative.14082e9d.js","sourceRoot":"..","sourcesContent":["import { ICollidable } from './ICollidable';\r\nimport { IPoint } from './IPoint';\r\nimport { TileMap } from './TileMap';\r\n\r\nexport class Collider {\r\n\r\n    constructor (private map: TileMap) { }\r\n\r\n    public setMap (map: TileMap) {\r\n        this.map = map;\r\n    }\r\n\r\n    public collide (object: ICollidable) {\r\n        this.collidePoint(object, {\r\n            x: object.x,\r\n            y: object.y - object.height / 2\r\n        }, true, false, false, false);\r\n\r\n        this.collidePoint(object, {\r\n            x: object.x + object.width / 2,\r\n            y: object.y\r\n        }, false, true, false, false);\r\n\r\n        this.collidePoint(object, {\r\n            x: object.x,\r\n            y: object.y + object.height / 2\r\n        }, false, false, true, false);\r\n\r\n        this.collidePoint(object, {\r\n            x: object.x - object.width / 2,\r\n            y: object.y\r\n        }, false, false, false, true);\r\n    }\r\n\r\n    public collidePoint (object: ICollidable, point: IPoint, top: boolean, right: boolean, bottom: boolean, left: boolean) {\r\n        const tilePosition = {\r\n            x: Math.floor(point.x),\r\n            y: Math.floor(point.y)\r\n        };\r\n        const tile = this.map.getTile(tilePosition);\r\n\r\n        if (right && tile) { object.x = tilePosition.x - object.width / 2; }\r\n        if (left && tile) { object.x = tilePosition.x + 1 + object.width / 2; }\r\n        if (top && tile) { object.y = tilePosition.y + 1 + object.height / 2; }\r\n        if (bottom && tile) { object.y = tilePosition.y - object.height / 2; }\r\n\r\n    //     if (object.force.x > 0 && right) {\r\n    //         const tilePosition = {\r\n    //             x: Math.floor(point.x + object.force.x),\r\n    //             y: Math.floor(point.y)\r\n    //         };\r\n    //         const tile = this.map.getTile(tilePosition);\r\n    //         if (tile) {\r\n    //             const colliding = this.collideRight(object, point, tilePosition.x);\r\n    //             if (colliding) { return true; }\r\n    //         }\r\n    //     } else if (object.force.x < 0 && left) {\r\n    //         const tilePosition = {\r\n    //             x: Math.floor(point.x + object.force.x),\r\n    //             y: Math.floor(point.y)\r\n    //         };\r\n    //         const tile = this.map.getTile(tilePosition);\r\n    //         if (tile) {\r\n    //             const colliding = this.collideLeft(object, point, tilePosition.x + 1);\r\n    //             if (colliding) { return true; }\r\n    //         }\r\n    //     }\r\n\r\n    //     if (object.force.y > 0 && bottom) {\r\n    //         const tilePosition = {\r\n    //             x: Math.floor(point.x),\r\n    //             y: Math.floor(point.y + object.force.y)\r\n    //         };\r\n    //         const tile = this.map.getTile(tilePosition);\r\n    //         if (tile) {\r\n    //             const colliding = this.collideBottom(object, point, tilePosition.y);\r\n    //             if (colliding) { return true; }\r\n    //         }\r\n    //     } else if (object.force.y < 0 && top) {\r\n    //         const tilePosition = {\r\n    //             x: Math.floor(point.x),\r\n    //             y: Math.floor(point.y + object.force.y)\r\n    //         };\r\n    //         const tile = this.map.getTile(tilePosition);\r\n    //         if (tile) {\r\n    //             const colliding = this.collideTop(object, point, tilePosition.y + 1);\r\n    //             if (colliding) { return true; }\r\n    //         }\r\n    //     }\r\n\r\n    //     return false;\r\n    }\r\n\r\n    // private collideBottom (object: ICollidable, point: IPoint, tileY): boolean {\r\n    //     if (point.y + object.force.y > tileY) {\r\n    //         const diffY = point.y - object.y;\r\n    //         object.y = tileY + (-1 * diffY) - 0.001;\r\n    //         object.force.y = 0;\r\n    //         return true;\r\n    //     }\r\n    //     return false;\r\n    // }\r\n\r\n    // private collideTop (object: ICollidable, point: IPoint, tileY): boolean {\r\n    //     if (point.y + object.force.y < tileY) {\r\n    //         const diffY = point.y - object.y;\r\n    //         object.y = tileY + (-1 * diffY) + 0.001;\r\n    //         object.force.y = 0;\r\n    //         return true;\r\n    //     }\r\n    //     return false;\r\n    // }\r\n\r\n    // private collideRight (object: ICollidable, point: IPoint, tileX): boolean {\r\n    //     if (point.x + object.force.x > tileX) {\r\n    //         const diffX = point.x - object.x;\r\n    //         object.x = tileX + (-1 * diffX) - 0.001;\r\n    //         object.force.x = 0;\r\n    //         return true;\r\n\r\n    //     }\r\n    //     return false;\r\n    // }\r\n\r\n    // private collideLeft (object: ICollidable, point: IPoint, tileX): boolean {\r\n\r\n    //     if (point.x + object.force.x < tileX) {\r\n    //         const diffX = point.x - object.x;\r\n    //         object.x = tileX + (-1 * diffX) + 0.001;\r\n    //         object.force.x = 0;\r\n    //         return true;\r\n\r\n    //     }\r\n    //     return false;\r\n\r\n    // }\r\n}\r\n","export class Controls {\r\n    public up = false;\r\n    public down = false;\r\n    public left = false;\r\n    public right = false;\r\n    public shift = false;\r\n\r\n    private readonly keys = {\r\n        up: ['w', 'ArrowUp', ''],\r\n        down: ['s', 'ArrowDown'],\r\n        left: ['a', 'ArrowLeft'],\r\n        right: ['d', 'ArrowRight'],\r\n        shift: ['Shift']\r\n    };\r\n\r\n    constructor () {\r\n        document.onkeydown = (e) => this.keyDown(e);\r\n        document.onkeyup = (e) => this.keyUp(e);\r\n    }\r\n\r\n    private keyDown (e: KeyboardEvent) {\r\n        if (this.keys.up.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.up = true;\r\n        } else if (this.keys.down.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.down = true;\r\n        } else if (this.keys.left.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.left = true;\r\n        } else if (this.keys.right.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.right = true;\r\n        } else if (this.keys.shift.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.shift = true;\r\n        }\r\n    }\r\n\r\n    private keyUp (e: KeyboardEvent) {\r\n        if (this.keys.up.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.up = false;\r\n        } else if (this.keys.down.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.down = false;\r\n        } else if (this.keys.left.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.left = false;\r\n        } else if (this.keys.right.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.right = false;\r\n        } else if (this.keys.shift.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.shift = false;\r\n        }\r\n    }\r\n}\r\n","import { Collider } from './Collider';\r\nimport { Controls } from './Controls';\r\nimport { ICollidable } from './ICollidable';\r\nimport { IPoint } from './IPoint';\r\nimport { TileMap } from './TileMap';\r\n\r\nexport class Player implements IPoint, ICollidable {\r\n    public width: number = 0.8;\r\n    public height: number = 0.8;\r\n\r\n    constructor (public x = 0, public y = 0) {}\r\n\r\n    public update (controls: Controls, collider: Collider, delta: number) {\r\n        const speed = controls.shift ? delta / 60 : 0.5 * delta / 60;\r\n\r\n        if (controls.left) { this.x -= speed; }\r\n        if (controls.right) { this.x += speed; }\r\n        if (controls.up) { this.y -= speed; }\r\n        if (controls.down) { this.y += speed; }\r\n\r\n        collider.collide(this);\r\n    }\r\n\r\n    public render (ctx: CanvasRenderingContext2D, tileSize: number) {\r\n        ctx.fillStyle = '#700070';\r\n        ctx.fillRect(\r\n            Math.round(ctx.canvas.width / 2) - Math.round(this.width * tileSize / 2),\r\n            Math.round(ctx.canvas.height / 2) - Math.round(this.height * tileSize / 2),\r\n            Math.round(this.width * tileSize),\r\n            Math.round(this.height * tileSize)\r\n        );\r\n    }\r\n}\r\n","import { IPoint } from './IPoint';\r\n\r\nexport class TileMap {\r\n    private tiles: number[] = [];\r\n\r\n    constructor (private width: number, private height: number) {\r\n        this.tiles = new Array(this.width * this.height);\r\n        this.tiles.fill(0);\r\n\r\n        this.tiles = this.tiles.map((value, i) => {\r\n            const position = this.toPosition(i);\r\n            if (position.y === 0 || position.y === this.height - 1 || position.x === 0 || position.x === this.width - 1) {\r\n                return 1;\r\n            }\r\n            return value;\r\n        });\r\n    }\r\n\r\n    public render (ctx: CanvasRenderingContext2D, offset: IPoint, tileSize: number) {\r\n        for (let i = 0; i < this.tiles.length; i++) {\r\n            const tile = this.tiles[i];\r\n            if (tile) {\r\n                const position = this.toPosition(i);\r\n\r\n                ctx.fillStyle = '#000';\r\n                ctx.fillRect(\r\n                    offset.x + position.x * tileSize,\r\n                    offset.y + position.y * tileSize,\r\n                    tileSize,\r\n                    tileSize\r\n                );\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public getTile (position: IPoint): number {\r\n        if (position.x >= 0 && position.x < this.width && position.y >= 0 && position.y < this.height) {\r\n            // console.log(position.x >= 0 && position.x < this.width && position.y >= 0 && position.y < this.height, this.toIndex(position));\r\n            return this.tiles[this.toIndex(position)];\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    private toIndex (position: IPoint): number {\r\n        return position.y * this.width + position.x;\r\n    }\r\n\r\n    private toPosition (index: number): IPoint {\r\n        return {\r\n            x: index % this.width,\r\n            y: Math.floor(index / this.width)\r\n        };\r\n    }\r\n}\r\n","import { Collider } from './Collider';\r\nimport { Controls } from './Controls';\r\nimport { IPoint } from './IPoint';\r\nimport { Player } from './Player';\r\nimport { TileMap } from './TileMap';\r\n\r\nexport class Game {\r\n    private tileMap: TileMap;\r\n    private player: Player;\r\n    private controls: Controls;\r\n    private collider: Collider;\r\n\r\n    constructor () {\r\n        this.tileMap = new TileMap(10, 10);\r\n        this.player = new Player(5, 5);\r\n        this.controls = new Controls();\r\n\r\n        this.collider = new Collider(this.tileMap);\r\n    }\r\n\r\n    public update (time: number, delta: number) {\r\n        this.player.update(this.controls, this.collider, delta);\r\n    }\r\n\r\n    public render (ctx: CanvasRenderingContext2D) {\r\n        const tileSize = 20;\r\n        const offset: IPoint = {\r\n            x: Math.round(ctx.canvas.width / 2) - Math.round(this.player.x * tileSize),\r\n            y: Math.round(ctx.canvas.height / 2) - Math.round(this.player.y * tileSize)\r\n        };\r\n\r\n        this.tileMap.render(ctx, offset, tileSize);\r\n        this.player.render(ctx, tileSize);\r\n    }\r\n}\r\n","import { Game } from './Game';\r\n\r\ndeclare global {\r\n    interface Window {\r\n        anim: number;\r\n        interval: number;\r\n        timeout: number;\r\n    }\r\n}\r\n\r\nexport class App {\r\n    private canvas: HTMLCanvasElement;\r\n    private ctx: CanvasRenderingContext2D;\r\n\r\n    private game: Game;\r\n\r\n    constructor () {\r\n        const old = document.querySelector('canvas');\r\n        if (old) { old.parentNode.removeChild(old); }\r\n\r\n        window.cancelAnimationFrame(window.anim);\r\n        window.clearInterval(window.interval);\r\n        window.clearTimeout(window.timeout);\r\n\r\n        this.canvas = document.createElement('canvas');\r\n        this.ctx = this.canvas.getContext('2d');\r\n\r\n        document.body.insertAdjacentElement('afterbegin', this.canvas);\r\n\r\n        window.onresize = () => this.resize();\r\n        this.resize();\r\n\r\n        this.run();\r\n    }\r\n\r\n    private run () {\r\n        console.clear();\r\n\r\n        this.game = new Game();\r\n\r\n        let previousTime = 0;\r\n        const step = (time: number) => {\r\n            window.anim = window.requestAnimationFrame((t) => step(t));\r\n            this.clear();\r\n\r\n            this.game.update(time, time - previousTime);\r\n            this.game.render(this.ctx);\r\n\r\n            previousTime = time;\r\n        };\r\n\r\n        window.anim = window.requestAnimationFrame((t) => step(t));\r\n    }\r\n\r\n    private clear () {\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    private resize () {\r\n        const w = window.innerWidth;\r\n        const h = window.innerHeight;\r\n\r\n        if (typeof window.devicePixelRatio === 'number') {\r\n            const deviceScale = Math.min(3.5, Math.floor(window.devicePixelRatio * 2) / 2);\r\n\r\n            this.canvas.width = w * deviceScale;\r\n            this.canvas.height = h * deviceScale;\r\n        } else {\r\n            this.canvas.width = w;\r\n            this.canvas.height = h;\r\n        }\r\n    }\r\n}\r\n","import { App } from './App';\r\n\r\nconsole.clear();\r\nconsole.log(new Date());\r\n\r\nnew App();\r\n"]}