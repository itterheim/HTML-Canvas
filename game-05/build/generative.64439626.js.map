{"version":3,"sources":["ts/Collider.ts","ts/Controls.ts","ts/Vector.ts","ts/Player.ts","ts/TileMap.ts","ts/Game.ts","ts/App.ts","ts/generative.ts"],"names":[],"mappings":"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","file":"generative.64439626.js","sourceRoot":"..","sourcesContent":["import { ICollidable } from './ICollidable';\r\nimport { IPoint } from './IPoint';\r\nimport { TileMap } from './TileMap';\r\n\r\nexport class Collider {\r\n\r\n    constructor (private map: TileMap) { }\r\n\r\n    public setMap (map: TileMap) {\r\n        this.map = map;\r\n    }\r\n\r\n    public collide (object) {\r\n        let colliding = false;\r\n\r\n        colliding = this.collidePoint(object, {\r\n            x: object.x - object.width / 2,\r\n            y: object.y - object.height / 2\r\n        }, true, false, false, true);\r\n        // if (colliding) { return; }\r\n\r\n        colliding = this.collidePoint(object, {\r\n            x: object.x + object.width / 2,\r\n            y: object.y - object.height / 2\r\n        }, true, true, false, false);\r\n        // if (colliding) { return; }\r\n\r\n        colliding = this.collidePoint(object, {\r\n            x: object.x - object.width / 2,\r\n            y: object.y + object.height / 2\r\n        }, false, false, true, true);\r\n        // if (colliding) { return; }\r\n\r\n        colliding = this.collidePoint(object, {\r\n            x: object.x + object.width / 2,\r\n            y: object.y + object.height / 2\r\n        }, false, true, true, false);\r\n        // if (colliding) { return; }\r\n    }\r\n\r\n    public collidePoint (object: ICollidable, point: IPoint, top: boolean, right: boolean, bottom: boolean, left: boolean): boolean {\r\n        if (object.force.x > 0 && right) {\r\n            const tilePosition = {\r\n                x: Math.floor(point.x + object.force.x),\r\n                y: Math.floor(point.y)\r\n            };\r\n            const tile = this.map.getTile(tilePosition);\r\n            if (tile) {\r\n                const colliding = this.collideRight(object, point, tilePosition.x);\r\n                if (colliding) { return true; }\r\n            }\r\n        } else if (object.force.x < 0 && left) {\r\n            const tilePosition = {\r\n                x: Math.floor(point.x + object.force.x),\r\n                y: Math.floor(point.y)\r\n            };\r\n            const tile = this.map.getTile(tilePosition);\r\n            if (tile) {\r\n                const colliding = this.collideLeft(object, point, tilePosition.x + 1);\r\n                if (colliding) { return true; }\r\n            }\r\n        }\r\n\r\n        if (object.force.y > 0 && bottom) {\r\n            const tilePosition = {\r\n                x: Math.floor(point.x),\r\n                y: Math.floor(point.y + object.force.y)\r\n            };\r\n            const tile = this.map.getTile(tilePosition);\r\n            if (tile) {\r\n                const colliding = this.collideBottom(object, point, tilePosition.y);\r\n                if (colliding) { return true; }\r\n            }\r\n        } else if (object.force.y < 0 && top) {\r\n            const tilePosition = {\r\n                x: Math.floor(point.x),\r\n                y: Math.floor(point.y + object.force.y)\r\n            };\r\n            const tile = this.map.getTile(tilePosition);\r\n            if (tile) {\r\n                const colliding = this.collideTop(object, point, tilePosition.y + 1);\r\n                if (colliding) { return true; }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private collideBottom (object: ICollidable, point: IPoint, tileY): boolean {\r\n        if (point.y + object.force.y > tileY) {\r\n            const diffY = point.y - object.y;\r\n            object.y = tileY + (-1 * diffY) - 0.001;\r\n            object.force.y = 0;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private collideTop (object: ICollidable, point: IPoint, tileY): boolean {\r\n        if (point.y + object.force.y < tileY) {\r\n            const diffY = point.y - object.y;\r\n            object.y = tileY + (-1 * diffY) + 0.001;\r\n            object.force.y = 0;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private collideRight (object: ICollidable, point: IPoint, tileX): boolean {\r\n        if (point.x + object.force.x > tileX) {\r\n            const diffX = point.x - object.x;\r\n            object.x = tileX + (-1 * diffX) - 0.001;\r\n            object.force.x = 0;\r\n            return true;\r\n\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private collideLeft (object: ICollidable, point: IPoint, tileX): boolean {\r\n\r\n        if (point.x + object.force.x < tileX) {\r\n            const diffX = point.x - object.x;\r\n            object.x = tileX + (-1 * diffX) + 0.001;\r\n            object.force.x = 0;\r\n            return true;\r\n\r\n        }\r\n        return false;\r\n\r\n    }\r\n\r\n    // public collide (object: ICollidable) {\r\n\r\n    //     // if (object.force.x < 0 || object.force.y < 0) {\r\n    //     //     const topLeft = { x: object.x - object.width / 2, y: object.y - object.height / 2 };\r\n    //     //     this.collidePoint(object, topLeft);\r\n    //     // }\r\n    //     if (object.force.x > 0 || object.force.y < 0) {\r\n    //         const topRight = { x: object.x + object.width / 2, y: object.y - object.height / 2 - 0.0001 };\r\n    //         this.collidePoint(object, topRight);\r\n    //     }\r\n    //     // if (object.force.x < 0 || object.force.y > 0) {\r\n    //     //     const bottomLeft = { x: object.x - object.width / 2, y: object.y + object.height / 2 - 0.0001 };\r\n    //     //     this.collidePoint(object, bottomLeft);\r\n    //     // }\r\n    //     // if (object.force.x > 0 || object.force.y > 0) {\r\n    //     //     const bottomRight = { x: object.x + object.width / 2, y: object.y + object.height / 2 - 0.0001 };\r\n    //     //     this.collidePoint(object, bottomRight);\r\n    //     // }\r\n    // }\r\n\r\n    // private collidePoint (object: ICollidable, point: IPoint) {\r\n    //     // const tileX = Math.floor(point.x + object.force.x);\r\n    //     // const tileY = Math.floor(point.y + object.force.y);\r\n    //     // const tile = this.map.getTile({ x: tileX, y: tileY });\r\n\r\n    //     // console.log(tile, tileX, tileY);\r\n    //     const tileVX = Math.floor(point.x);\r\n    //     const tileVY = Math.floor(point.y + object.force.y);\r\n    //     const tileV = this.map.getTile({ x: tileVX, y: tileVY });\r\n\r\n    //     const tileHX = Math.floor(point.x + object.force.x);\r\n    //     const tileHY = Math.floor(point.y - 0.0001);\r\n    //     const tileH = this.map.getTile({ x: tileHX, y: tileHY });\r\n\r\n    //     // console.log(tileH, tileHX, tileHY);\r\n\r\n    //     // console.log(tile, tileX, tileY);\r\n\r\n    //     // this.map.ti\r\n    //     // console.log(tile, tileY * 5 + tileX);\r\n\r\n    //     // console.log(tile, tileY);\r\n    //     if (tileV) {\r\n    //         if (object.force.y < 0) { this.collideTop(object, point, tileVY + 1); }\r\n    //         if (object.force.y > 0) { this.collideBottom(object, point, tileVY); }\r\n    //     }\r\n    //     if (tileH) {\r\n    //         if (object.force.x < 0) { this.collideLeft(object, point, tileHX + 1); }\r\n    //         if (object.force.x > 0) { this.collideRight(object, point, tileHX); }\r\n    //     }\r\n    // }\r\n\r\n    // private collideLeft (object: ICollidable, point: IPoint, tileX: number) {\r\n    //     const diffX = object.x - point.x;\r\n    //     const x = point.x + object.force.x;\r\n    //     if (x < tileX) {\r\n    //         object.force.x = 0;\r\n    //         console.log(diffX);\r\n    //         object.x = tileX + diffX;\r\n    //     }\r\n    // }\r\n\r\n    // private collideRight (object: ICollidable, point: IPoint, tileX: number) {\r\n    //     const diffX = object.x - point.x;\r\n    //     const x = point.x + object.force.x;\r\n    //     if (x > tileX) {\r\n    //         object.force.x = 0;\r\n    //         object.x = tileX + diffX;\r\n    //     }\r\n    // }\r\n\r\n    // private collideTop (object: ICollidable, point: IPoint, tileY: number) {\r\n    //     const diffY = object.y - point.y;\r\n    //     const y = point.y + object.force.y;\r\n    //     if (y < tileY) {\r\n    //         object.force.y = 0;\r\n    //         object.y = tileY + diffY;\r\n    //     }\r\n    // }\r\n\r\n    // private collideBottom (object: ICollidable, point: IPoint, tileY: number) {\r\n    //     const diffY = object.y - point.y;\r\n    //     const y = point.y + object.force.y;\r\n    //     if (y > tileY) {\r\n    //         object.force.y = 0;\r\n    //         object.y = tileY + diffY;\r\n    //     }\r\n    // }\r\n}\r\n","export class Controls {\r\n    public up = false;\r\n    public down = false;\r\n    public left = false;\r\n    public right = false;\r\n\r\n    private readonly keys = {\r\n        up: ['w', 'ArrowUp', ''],\r\n        down: ['s', 'ArrowDown'],\r\n        left: ['a', 'ArrowLeft'],\r\n        right: ['d', 'ArrowRight']\r\n    };\r\n\r\n    constructor () {\r\n        document.onkeydown = (e) => this.keyDown(e);\r\n        document.onkeyup = (e) => this.keyUp(e);\r\n    }\r\n\r\n    private keyDown (e: KeyboardEvent) {\r\n\r\n        if (this.keys.up.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.up = true;\r\n        } else if (this.keys.down.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.down = true;\r\n        } else if (this.keys.left.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.left = true;\r\n        } else if (this.keys.right.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.right = true;\r\n        }\r\n    }\r\n\r\n    private keyUp (e: KeyboardEvent) {\r\n        if (this.keys.up.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.up = false;\r\n        } else if (this.keys.down.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.down = false;\r\n        } else if (this.keys.left.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.left = false;\r\n        } else if (this.keys.right.indexOf(e.key) > -1) {\r\n            e.preventDefault();\r\n            this.right = false;\r\n        }\r\n    }\r\n}\r\n","import { IPoint } from './IPoint';\r\n\r\nexport class Vector implements IPoint {\r\n    constructor (public x: number = 0, public y: number = 0) {}\r\n\r\n    public clone (): Vector {\r\n        return new Vector(this.x, this.y);\r\n    }\r\n\r\n    public add (vector: Vector): Vector {\r\n        this.x += vector.x;\r\n        this.y += vector.y;\r\n        return this;\r\n    }\r\n\r\n    public subtract (vector: Vector): Vector {\r\n        this.x -= vector.x;\r\n        this.y -= vector.y;\r\n        return this;\r\n    }\r\n\r\n    public multiply (n: number): Vector {\r\n        this.x *= n;\r\n        this.y *= n;\r\n        return this;\r\n    }\r\n}\r\n","import { Collider } from './Collider';\r\nimport { Controls } from './Controls';\r\nimport { ICollidable } from './ICollidable';\r\nimport { Vector } from './Vector';\r\n\r\nexport class Player implements ICollidable {\r\n    public width = 0.8;\r\n    public height = 0.8;\r\n    public force = new Vector();\r\n\r\n    constructor (public x: number = 0, public y: number = 0) { }\r\n\r\n    public update (controls: Controls, collider: Collider, delta: number) {\r\n\r\n        this.addGravity(delta);\r\n\r\n        const controlsForce = 0.1;\r\n\r\n        if (controls.up) { this.force.add(new Vector(0, -1 * controlsForce)); }\r\n        if (controls.down) { this.force.add(new Vector(0, controlsForce)); }\r\n        if (controls.left) { this.force.add(new Vector(-1 * controlsForce, 0)); }\r\n        if (controls.right) { this.force.add(new Vector(controlsForce, 0)); }\r\n\r\n        collider.collide(this);\r\n\r\n        this.x += this.force.x;\r\n        this.y += this.force.y;\r\n        this.force.multiply(0.9);\r\n\r\n        if (Math.abs(this.force.x) < 0.015) { this.force.x = 0; }\r\n        if (Math.abs(this.force.y) < 0.015) { this.force.y = 0; }\r\n    }\r\n\r\n    public render (ctx: CanvasRenderingContext2D, tileSize: number) {\r\n        ctx.fillStyle = '#700070';\r\n        ctx.fillRect(\r\n            Math.round(ctx.canvas.width / 2) - Math.round(this.width * tileSize / 2),\r\n            Math.round(ctx.canvas.height / 2) - Math.round(this.height * tileSize / 2),\r\n            Math.round(this.width * tileSize),\r\n            Math.round(this.height * tileSize)\r\n        );\r\n    }\r\n\r\n    public addForce (force: Vector) {\r\n        this.force.add(force);\r\n    }\r\n\r\n    private addGravity (delta: number) {\r\n        this.force.add(new Vector(0, 0.5).multiply(1 / delta));\r\n    }\r\n}\r\n","import { IPoint } from './IPoint';\r\n\r\nexport class TileMap {\r\n    // private tiles: number[] = [\r\n    //     0, 0, 0, 0, 0,\r\n    //     0, 0, 0, 0, 0,\r\n    //     0, 0, 0, 0, 0,\r\n    //     0, 0, 0, 0, 0,\r\n    //     1, 1, 1, 1, 1\r\n    // ];\r\n    private tiles: number[];\r\n\r\n    constructor (private width: number, private height: number) {\r\n        this.tiles = new Array(this.width * this.height);\r\n        this.tiles.fill(0);\r\n\r\n        this.tiles = this.tiles.map((value, i) => {\r\n            const position = this.toPosition(i);\r\n            if (position.y === 0 || position.y === this.height - 1 || position.x === 0 || position.x === this.width - 1) {\r\n                return 1;\r\n            }\r\n            return value;\r\n        });\r\n    }\r\n\r\n    public render (ctx: CanvasRenderingContext2D, offset: IPoint, tileSize: number) {\r\n\r\n        for (let i = 0; i < this.tiles.length; i++) {\r\n            const tile = this.tiles[i];\r\n            if (tile) {\r\n                const position = this.toPosition(i);\r\n\r\n                ctx.fillStyle = '#000';\r\n                ctx.fillRect(\r\n                    offset.x + position.x * tileSize,\r\n                    offset.y + position.y * tileSize,\r\n                    tileSize,\r\n                    tileSize\r\n                );\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public getTile (position: IPoint): number {\r\n        if (position.x >= 0 && position.x < this.width && position.y >= 0 && position.y < this.height) {\r\n            // console.log(position.x >= 0 && position.x < this.width && position.y >= 0 && position.y < this.height, this.toIndex(position));\r\n            return this.tiles[this.toIndex(position)];\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    private toIndex (position: IPoint): number {\r\n        return position.y * this.width + position.x;\r\n    }\r\n\r\n    private toPosition (index: number): IPoint {\r\n        return {\r\n            x: index % this.width,\r\n            y: Math.floor(index / this.width)\r\n        };\r\n    }\r\n}\r\n","import { Collider } from './Collider';\r\nimport { Controls } from './Controls';\r\nimport { IPoint } from './IPoint';\r\nimport { Player } from './Player';\r\nimport { TileMap } from './TileMap';\r\nimport { Vector } from './Vector';\r\n\r\nexport class Game {\r\n    private map: TileMap;\r\n    private player: Player;\r\n    private collider: Collider;\r\n    private controls: Controls;\r\n\r\n    constructor () {\r\n        this.controls = new Controls();\r\n        this.player = new Player(2.5, 2.5);\r\n        this.map = new TileMap(10, 10);\r\n        this.collider = new Collider(this.map);\r\n    }\r\n\r\n    public update (time: number, delta: number) {\r\n        // if (this.player.y > 20 || time > 2000) { return; }\r\n\r\n        this.player.update(this.controls, this.collider, delta);\r\n    }\r\n\r\n    public render (ctx: CanvasRenderingContext2D) {\r\n        const tileSize = 20;\r\n        const offset: IPoint = {\r\n            x: Math.round(ctx.canvas.width / 2) - Math.round(this.player.x * tileSize),\r\n            y: Math.round(ctx.canvas.height / 2) - Math.round(this.player.y * tileSize)\r\n        };\r\n\r\n        this.map.render(ctx, offset, tileSize);\r\n        this.player.render(ctx, tileSize);\r\n    }\r\n}\r\n","import { Game } from './Game';\r\n\r\ndeclare global {\r\n    interface Window {\r\n        anim: number;\r\n        interval: number;\r\n        timeout: number;\r\n    }\r\n}\r\n\r\nexport class App {\r\n    private canvas: HTMLCanvasElement;\r\n    private ctx: CanvasRenderingContext2D;\r\n\r\n    private game: Game;\r\n\r\n    constructor () {\r\n        const old = document.querySelector('canvas');\r\n        if (old) { old.parentNode.removeChild(old); }\r\n\r\n        window.cancelAnimationFrame(window.anim);\r\n        window.clearInterval(window.interval);\r\n        window.clearTimeout(window.timeout);\r\n\r\n        this.canvas = document.createElement('canvas');\r\n        this.ctx = this.canvas.getContext('2d');\r\n\r\n        document.body.insertAdjacentElement('afterbegin', this.canvas);\r\n\r\n        window.onresize = () => this.resize();\r\n        this.resize();\r\n\r\n        this.run();\r\n    }\r\n\r\n    private run () {\r\n        console.clear();\r\n\r\n        this.game = new Game();\r\n\r\n        let previousTime = 0;\r\n        const step = (time: number) => {\r\n            window.anim = window.requestAnimationFrame((t) => step(t));\r\n            this.clear();\r\n\r\n            this.game.update(time, time - previousTime);\r\n            this.game.render(this.ctx);\r\n\r\n            previousTime = time;\r\n        };\r\n\r\n        window.anim = window.requestAnimationFrame((t) => step(t));\r\n    }\r\n\r\n    private clear () {\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    private resize () {\r\n        const w = window.innerWidth;\r\n        const h = window.innerHeight;\r\n\r\n        if (typeof window.devicePixelRatio === 'number') {\r\n            const deviceScale = Math.min(3.5, Math.floor(window.devicePixelRatio * 2) / 2);\r\n\r\n            this.canvas.width = w * deviceScale;\r\n            this.canvas.height = h * deviceScale;\r\n        } else {\r\n            // config.deviceScale = 1;\r\n            this.canvas.width = w;\r\n            this.canvas.height = h;\r\n        }\r\n\r\n        // config.tileSize = Math.floor(Math.min(this.canvas.width, this.canvas.height / config.minTiles));\r\n    }\r\n}\r\n","import { App } from './App';\r\n\r\nconsole.clear();\r\nconsole.log(new Date());\r\n\r\nnew App();\r\n"]}