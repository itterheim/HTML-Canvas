{"version":3,"sources":["ts/Tiles/CircleTile.ts","ts/Tiles/RectTile.ts","ts/Tiles/VoidTile.ts","ts/Tiles/Tiles.ts","ts/App.ts","ts/generative.ts"],"names":[],"mappings":"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","file":"generative.9643ecee.map","sourceRoot":"..","sourcesContent":["import { ITile } from './ITile';\r\n\r\nexport class CircleTile implements ITile {\r\n    public readonly type = 'circle';\r\n\r\n    constructor (public x: number, public y: number, public size: number) {}\r\n\r\n    public render (ctx: CanvasRenderingContext2D) {\r\n        ctx.fillStyle = `rgba(150, 225, 0, ${Math.random()})`;\r\n\r\n        ctx.beginPath();\r\n        ctx.arc(this.x + this.size / 2, this.y + this.size / 2, (this.size / 2) - 2, 0, 2 * Math.PI);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n    }\r\n}\r\n","import { ITile } from './ITile';\r\n\r\nexport class RectTile implements ITile {\r\n    public readonly type = 'rect';\r\n\r\n    constructor (public x: number, public y: number, public size: number) {}\r\n\r\n    public render (ctx: CanvasRenderingContext2D) {\r\n        ctx.strokeStyle = `rgba(0,150,225,${Math.random()})`;\r\n        ctx.lineWidth = 2.5;\r\n        ctx.strokeRect(this.x + 4, this.y + 4, this.size - 8, this.size - 8);\r\n    }\r\n}\r\n","import { ITile } from './ITile';\r\n\r\nexport class VoidTile implements ITile {\r\n    public readonly type = 'void';\r\n\r\n    constructor (public x: number, public y: number, public size: number) {}\r\n\r\n    public render (ctx: CanvasRenderingContext2D) {\r\n        ctx.clearRect(this.x + 1, this.y + 1, this.size - 2, this.size - 2);\r\n    }\r\n}\r\n","import { CircleTile } from './CircleTile';\r\nimport { RectTile } from './RectTile';\r\nimport { VoidTile } from './VoidTile';\r\n\r\nexport const Types = [\r\n    { type: 'circle', cls: CircleTile },\r\n    { type: 'rect', cls: RectTile },\r\n    { type: 'void', cls: VoidTile }\r\n];\r\n","import { CircleTile } from './Tiles/CircleTile';\r\nimport { ITile } from './Tiles/ITile';\r\nimport { RectTile } from './Tiles/RectTile';\r\nimport { Types } from './Tiles/Tiles';\r\nimport { VoidTile } from './Tiles/VoidTile';\r\n\r\nexport class App {\r\n    private canvas: HTMLCanvasElement;\r\n    private ctx: CanvasRenderingContext2D;\r\n\r\n    private offset: number = 200;\r\n    private tileSize: number = 20;\r\n    private tiles: ITile[][] = [];\r\n\r\n    private padding: {w: number, h: number} = { w: 0, h: 0 };\r\n    private count: {w: number, h: number} = { w: 0, h: 0 };\r\n\r\n    constructor () {\r\n        console.clear();\r\n        this.canvas = document.getElementById('image') as HTMLCanvasElement;\r\n        this.ctx = this.canvas.getContext('2d');\r\n\r\n        this.canvas.width = window.innerWidth;\r\n        this.canvas.height = window.innerHeight;\r\n\r\n        this.count.w = Math.floor((this.canvas.width - this.offset) / this.tileSize);\r\n        this.padding.w = Math.round((this.canvas.width - (this.count.w * this.tileSize)) / 2) + 0.5;\r\n        this.count.h = Math.floor((this.canvas.height - this.offset) / this.tileSize);\r\n        this.padding.h = Math.round((this.canvas.height - (this.count.h * this.tileSize)) / 2) + 0.5;\r\n\r\n        this.run();\r\n    }\r\n\r\n    public run () {\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n        for (let x = 0; x < this.count.w; x++) {\r\n            this.tiles[x] = [];\r\n\r\n            for (let y = 0; y < this.count.h; y++) {\r\n                const tile = this.getTile(x, y);\r\n                this.tiles[x].push(tile);\r\n            }\r\n        }\r\n\r\n        this.render();\r\n    }\r\n\r\n    private render () {\r\n        for (const column of this.tiles) {\r\n            for (const tile of column) {\r\n                tile.render(this.ctx);\r\n            }\r\n        }\r\n\r\n        for (let xi = 0; xi < this.tiles.length - 1; xi++) {\r\n            for (let yi = 0; yi < this.tiles[xi].length; yi++) {\r\n                if (this.tiles[xi][yi].type === 'void') {\r\n                    this.drawLine(this.tiles[xi][yi], this.tiles[xi + 1][yi + 1]);\r\n                    this.drawLine(this.tiles[xi][yi], this.tiles[xi + 1][yi - 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        console.log(this.tiles);\r\n    }\r\n\r\n    private drawLine (from, to) {\r\n        if (!from || !to) { return; }\r\n        if (from.type !== 'void' || to.type !== 'void') { return; }\r\n\r\n        const offset = this.tileSize / 2;\r\n\r\n        this.ctx.beginPath();\r\n        this.ctx.strokeStyle = '#faa';\r\n        this.ctx.lineWidth = 3;\r\n        this.ctx.lineCap = 'square';\r\n        this.ctx.moveTo(from.x + offset, from.y + offset);\r\n        this.ctx.lineTo(to.x + offset, to.y + offset);\r\n        this.ctx.stroke();\r\n    }\r\n\r\n    private getTile (xi: number, yi: number): ITile {\r\n        const x = this.padding.w + xi * this.tileSize;\r\n        const y = this.padding.h + yi * this.tileSize;\r\n\r\n        const exclude: string[] = [];\r\n\r\n        const top = this.tiles[xi][yi - 1];\r\n        const left = (this.tiles[xi - 1] || [])[yi];\r\n        if (top) { exclude.push(top.type); }\r\n        if (left) { exclude.push(left.type); }\r\n\r\n        const available = Types.filter((a) => exclude.indexOf(a.type) === -1);\r\n        const n = Math.floor(Math.random() * available.length);\r\n\r\n        return new available[n].cls(x, y, this.tileSize);\r\n    }\r\n}\r\n","import { App } from './App';\r\n\r\nconst app = new App();\r\n// app.run();\r\n"]}